<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap-3b89f33f99cf1e377f6c2112e29fdc73.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="self-hosted-ai-starter-kit-vom-n8n-team-modifiziert-von-felix" class="level1">
<h1>Self-hosted AI Starter Kit (vom n8n-Team), modifiziert von Felix</h1>
<p><strong>Self-hosted AI Starter Kit</strong> ist ein offenes, Docker Compose Template, das eine voll ausgestattete lokale AI- und Low-Code-Entwicklungsumgebung schnell einrichtet, einschließlich Open WebUI als Interface zum Chatten mit deinen n8n-Agenten.</p>
<p>Dies ist die Version von Felix mit einigen Verbesserungen sowie der Erweiterung um Open WebUI, Flowise, Elasticsearch, Kibana! Außerdem wird der lokale RAG AI Agent Workflow aus dem Video automatisch in deiner n8n-Instanz vorhanden sein, wenn du dieses Setup anstelle der von n8n bereitgestellten Basis verwendest!</p>
<p>Original wurde die Erweiterung mit OpenWebUI und Flowise von Coleam00 auf GitHub veröffentlicht.</p>
<p>Ich werde den Flowchart, bzw. die Tools ständig erweitern, und diese im Toturial mit aufnehmen.</p>
<p><a href="https://github.com/n8n-io/self-hosted-ai-starter-kit">Original Local AI Starter Kit</a></p>
<p>Lade die N8N + Open WebUI Integration <a href="https://openwebui.com/f/coleam/n8n_pipe/">direkt auf der Open WebUI Website herunter.</a> (Weitere Anleitungen unten)</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://raw.githubusercontent.com/n8n-io/self-hosted-ai-starter-kit/main/assets/n8n-demo.gif" class="img-fluid figure-img"></p>
<figcaption>n8n.io - Screenshot</figcaption>
</figure>
</div>
<p>Kuratiert von <a href="https://github.com/n8n-io" class="uri">https://github.com/n8n-io</a> und <a href="https://github.com/coleam00" class="uri">https://github.com/coleam00</a>, modifiziert und erweitert von Felix, kombiniert es die self-hosted n8n-Plattform mit einer kuratierten Liste kompatibler AI-Produkte und Komponenten, um schnell mit dem Aufbau von self-hosted AI-Workflows zu beginnen.</p>
<section id="enthaltene-komponenten" class="level3">
<h3 class="anchored" data-anchor-id="enthaltene-komponenten">Enthaltene Komponenten</h3>
<p>✅ <a href="https://n8n.io/"><strong>Self-hosted n8n</strong></a> - Low-Code-Plattform mit über 400 Integrationen und fortschrittlichen AI-Komponenten</p>
<p>✅ <a href="https://ollama.com/"><strong>Ollama</strong></a> - Plattformübergreifende LLM-Plattform zur Installation und Ausführung der neuesten lokalen LLMs</p>
<p>✅ <a href="https://openwebui.com/"><strong>Open WebUI</strong></a> - ChatGPT-ähnliches Interface zur privaten Interaktion mit deinen lokalen Modellen und n8n-Agenten</p>
<p>✅ <a href="https://flowiseai.com/"><strong>Flowise</strong></a> - No/Low-Code AI-Agent-Builder, der sich hervorragend mit n8n kombiniert</p>
<p>✅ <a href="https://qdrant.tech/"><strong>Qdrant</strong></a> - Open-Source, hochperformanter Vektorspeicher mit einer umfassenden API</p>
<p>✅ <a href="https://www.postgresql.org/"><strong>PostgreSQL</strong></a> - Arbeitspferd der Data Engineering-Welt, das große Datenmengen sicher verarbeitet</p>
<p>✅ <a href="https://www.elastic.co/de/elasticsearch"><strong>Elasticsearch</strong></a> - Dokumenten-/Vektorspeicher</p>
<p>✅ <a href="https://www.elastic.co/de/kibana"><strong>Kibana</strong></a> - Dashboard für Elasticsearch</p>
<p>✅ <a href="https://docs.crawl4ai.com/"><strong>Crawl4ai</strong></a> - Crawler Container</p>
<p>✅ <a href="https://github.com/microsoft/markitdown"><strong>markitdown</strong></a> - File Extractor Container (PDF, OCR, usw.)</p>
</section>
<section id="installation" class="level2">
<h2 class="anchored" data-anchor-id="installation">Installation</h2>
<section id="für-nvidia-gpu-nutzer" class="level3">
<h3 class="anchored" data-anchor-id="für-nvidia-gpu-nutzer">Für Nvidia GPU-Nutzer</h3>
<pre><code>git clone https://github.com/nashtrader/localAIagent.git
cd localAIagent</code></pre>
<p><strong>SUPER WICHTIG</strong>: Nun musst du die .env.example Datei in .env umbenennen ansonsten wird es nicht funktionieren! Falls du das schon ohne Umbenennen ausgeführt hast, dann musst du Docker Volumes löschen, da sonst die Konfiguration nicht übernommen wird.</p>
<p>Dann starte den Docker Container mit GPU Unterstützung:</p>
<pre><code>docker compose --profile gpu-nvidia up</code></pre>
<blockquote class="blockquote">
<p>[!HINWEIS] Falls du deine Nvidia GPU noch nicht mit Docker verwendet hast, folge bitte den <a href="https://github.com/ollama/ollama/blob/main/docs/docker.md">Ollama Docker-Anweisungen</a>.</p>
</blockquote>
</section>
<section id="für-mac-apple-silicon-nutzer" class="level3">
<h3 class="anchored" data-anchor-id="für-mac-apple-silicon-nutzer">Für Mac / Apple Silicon-Nutzer</h3>
<p>Falls du einen Mac mit einem M1 oder neueren Prozessor nutzt, kannst du deine GPU leider nicht für die Docker-Instanz freigeben. Es gibt zwei Möglichkeiten:</p>
<ol type="1">
<li>Das Starter Kit vollständig auf der CPU ausführen (siehe “Für alle anderen” unten)</li>
<li>Ollama auf deinem Mac ausführen für schnellere Inferenz und sich mit n8n verbinden</li>
</ol>
<p>Es hat sich gezeigt, das es auf Macs sinnvoller ist, Ollama ohne Docker zu verwenden. Da die Docker Container bei Macs nicht auf die GPU zugreifen können, ist die Inferenzgeschwindigkeit auf der CPU sehr langsam.</p>
<p>Falls du Ollama auf deinem Mac nutzen möchtest, besuche die <a href="https://ollama.com/">Ollama Homepage</a> für Installationsanweisungen und starte das Starter Kit folgendermaßen:</p>
<pre><code>git clone https://github.com/nashtrader/localAIagent.git
cd localAIagent</code></pre>
<p><strong>SUPER WICHTIG</strong>: Nun musst du die .env.example Datei in .env umbenennen ansonsten wird es nicht funktionieren! Falls du das schon ohne Umbenennen ausgeführt hast, dann musst du Docker Volumes löschen, da sonst die Konfiguration nicht übernommen wird.</p>
<p>Dann starte den Docker Container ohne GPU Unterstützung:</p>
<pre><code>docker compose up</code></pre>
<p>Nach Abschluss der Schnellstart-Einrichtung unten, ändere die Ollama-Anmeldeinformationen, indem du <code>http://host.docker.internal:11434/</code> als Host verwendest.</p>
</section>
<section id="für-alle-anderen" class="level3">
<h3 class="anchored" data-anchor-id="für-alle-anderen">Für alle anderen</h3>
<pre><code>git clone https://github.com/nashtrader/localAIagent.git
cd localAIagent</code></pre>
<p><strong>SUPER WICHTIG</strong>: Nun musst du die .env.example Datei in .env umbenennen ansonsten wird es nicht funktionieren! Falls du das schon ohne Umbenennen ausgeführt hast, dann musst du Docker Volumes löschen, da sonst die Konfiguration nicht übernommen wird.</p>
<p>Dann starte den Docker Container ohne GPU Unterstützung:</p>
<pre><code>docker compose --profile cpu up</code></pre>
</section>
</section>
<section id="schnellstart-und-nutzung" class="level2">
<h2 class="anchored" data-anchor-id="schnellstart-und-nutzung">⚡️ Schnellstart und Nutzung</h2>
<p>Das Hauptbestandteil des Self-hosted AI Starter Kits ist eine vorkonfigurierte Docker-Compose-Datei mit Netzwerk- und Datenträgerunterstützung, sodass nicht viel weiteres installiert werden muss. Nach der Installation folge diesen Schritten:</p>
<ol type="1">
<li><p>Öffne <a href="http://localhost:5678/" class="uri">http://localhost:5678/</a> in deinem Browser, um n8n einzurichten. Dies muss nur einmal gemacht werden. Du erstellst hier <strong>kein Konto bei n8n</strong>, sondern nur ein lokales Konto für deine Instanz!</p></li>
<li><p>Öffne den enthaltenen Workflow: <a href="http://localhost:5678/workflow/vTN9y2dLXqTiDfPT" class="uri">http://localhost:5678/workflow/vTN9y2dLXqTiDfPT</a></p></li>
<li><p>Erstelle Zugangsdaten für jeden Dienst:</p>
<ul>
<li><strong>Ollama URL</strong>: <code>http://ollama:11434</code></li>
<li><strong>Postgres</strong>: Nutze die DB, den Benutzernamen und das Passwort aus der <code>.env</code>. Host ist <code>postgres</code></li>
<li><strong>Qdrant URL</strong>: <code>http://qdrant:6333</code> (API-Schlüssel kann beliebig sein, da es lokal läuft)</li>
<li><strong>Google Drive</strong>: Folge <a href="https://docs.n8n.io/integrations/builtin/credentials/google/">diesem n8n-Leitfaden</a>.</li>
<li><strong>ngrok</strong>: Erstelle dir ein ngrok Account um Webhooks auf deine locale Umgebung zu tunneln.</li>
<li><strong>Telegramm</strong>: Erstelle dir ein Telegramm Account um auch von Unterwegs auf deinen localen Agenten zuzugreifen.</li>
</ul></li>
<li><p>Wähle <strong>Test Workflow</strong>, um den Workflow zu starten.</p></li>
<li><p>Falls es dein erster Start ist, muss Ollama Llama3.1 herunterladen. Überprüfe die Docker-Logs für den Fortschritt.</p></li>
<li><p>Stelle sicher, dass der Workflow aktiv geschaltet ist und kopiere die “Production” Webhook-URL!</p></li>
<li><p>Öffne <a href="http://localhost:3000/" class="uri">http://localhost:3000/</a> im Browser, um Open WebUI einzurichten. Auch hier: <strong>Kein Online-Konto, sondern nur ein lokales Konto!</strong></p></li>
<li><p>Gehe zu <strong>Workspace -&gt; Functions -&gt; Add Function</strong>, gib einen Namen und eine Beschreibung ein und füge den Code aus <code>n8n_pipe.py</code> ein.</p></li>
<li><p>Klicke auf das Zahnrad-Symbol und setze <code>n8n_url</code> auf die kopierte Webhook-URL.</p></li>
<li><p>Aktiviere die Funktion, und sie wird nun in deinem Modell-Dropdown verfügbar sein!</p></li>
</ol>
</section>
<section id="upgrade-anweisungen" class="level2">
<h2 class="anchored" data-anchor-id="upgrade-anweisungen">Upgrade-Anweisungen</h2>
<section id="für-nvidia-gpu-nutzer-1" class="level3">
<h3 class="anchored" data-anchor-id="für-nvidia-gpu-nutzer-1">Für Nvidia GPU-Nutzer</h3>
<pre><code>docker compose --profile gpu-nvidia pull
docker compose create &amp;&amp; docker compose --profile gpu-nvidia up</code></pre>
</section>
<section id="für-mac-apple-silicon-nutzer-1" class="level3">
<h3 class="anchored" data-anchor-id="für-mac-apple-silicon-nutzer-1">Für Mac / Apple Silicon-Nutzer</h3>
<pre><code>docker compose pull
docker compose create &amp;&amp; docker compose up</code></pre>
</section>
<section id="für-alle-anderen-1" class="level3">
<h3 class="anchored" data-anchor-id="für-alle-anderen-1">Für alle anderen</h3>
<pre><code>docker compose --profile cpu pull
docker compose create &amp;&amp; docker compose --profile cpu up</code></pre>
</section>
</section>
<section id="lizenz" class="level2">
<h2 class="anchored" data-anchor-id="lizenz">📜 Lizenz</h2>
<p>Dieses Projekt (ursprünglich erstellt vom n8n-Team, Link oben in der README) steht unter der Apache License 2.0 - siehe die <a href="LICENSE">LICENSE</a>-Datei für Details.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>